/*{
    "author": "OmniAutomation Assistant",
    "targets": ["omnifocus"],
    "type": "action",
    "identifier": "com.omnifocus.assistant.productivityReport",
    "version": "1.0",
    "description": "This script provides an overview of the completed tasks for the current day or week.",
    "label": "Productivity Report",
    "mediumLabel": "Productivity Report",
    "paletteLabel": "Productivity Report",
    "image": "arrow.up.doc"
}*/

/// <reference path="./types/omnifocus.d.ts" />
/// <reference path="./types/productivity-report.d.ts" />

(() => {
  /** @type {string} */
  const webhookService = "com.omnifocus.assistant.webhook";
  /** @type {Credentials} */
  const credentials = new Credentials();

  /**
   * Retrieves the webhook URL from credentials or requests it from the user
   * @returns {Promise<string>} The webhook URL
   */
  async function retrieveOrRequestWebhookUrl() {
    /** @type {Credential | null} */
    const credential = await credentials.read(webhookService);
    if (!credential) {
      /** @type {Form} */
      const inputForm = new Form();
      /** @type {Form.Field.String} */
      const webhookField = new Form.Field.String("webhookUrl", "Webhook URL", "");
      inputForm.addField(webhookField);
      /** @type {string} */
      const formPrompt = "Enter Webhook URL where results should be sent:";
      /** @type {{values: {webhookUrl: string}}} */
      const formObject = await inputForm.show(formPrompt, "Continue");
      /** @type {string} */
      const webhookUrl = formObject.values["webhookUrl"];
      await credentials.write(webhookService, "user", webhookUrl);
      return webhookUrl;
    } else {
      return credential.password;
    }
  }

  /**
   * Gets the appropriate suffix for a day number
   * @param {number} day - The day of the month
   * @returns {string} The suffix for the day
   */
  function getDaySuffix(day) {
    if (day >= 11 && day <= 13) {
      return "th";
    }
    switch (day % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  }

  /**
   * Gets the full project path, including all parent folders
   * @param {Project} project - The project
   * @returns {string} The full project path
   */
  function fullProjectPath(project) {
    /** @type {string} */
    let path = project.name;
    /** @type {Folder | null} */
    let parent = project.parentFolder;

    while (parent) {
      path = parent.name + " : " + path;
      parent = parent.parent;
    }

    return path;
  }

  /**
   * Gets the start date of the current week (Monday)
   * @param {Date} date - The reference date
   * @returns {Date} The start date of the week
   */
  function getWeekStartDate(date) {
    /** @type {Date} */
    const d = new Date(date);
    /** @type {number} */
    const day = d.getDay();
    /** @type {number} */
    const diff = d.getDate() - day + (day == 0 ? -6 : 1); // Adjust if day is Sunday
    return new Date(d.setDate(diff));
  }

  /**
   * Formats a date to a readable string
   * @param {Date} date - The date to format
   * @returns {string} The formatted date string
   */
  function formatDate(date) {
    /** @type {Date} */
    const d = new Date(date);
    /** @type {string} */
    const month = d.toLocaleString("default", { month: "long" });
    /** @type {number} */
    const day = d.getDate();
    /** @type {string} */
    const suffix = getDaySuffix(day);
    /** @type {number} */
    const year = d.getFullYear();
    return `${month} ${day}${suffix}`;
  }

  /**
   * Generates and sends a productivity report
   * @param {string} summaryType - The type of summary ("Daily" or "Weekly")
   */
  function generateReport(summaryType) {
    /** @type {Date} */
    let today = new Date();
    /** @type {string} */
    let startDateString, endDateString, dateLabel;
    /** @type {Date} */
    let startDate, endDate;

    if (summaryType === "Daily") {
      startDate = new Date(today);
      endDate = new Date(today);
      startDate.setHours(0, 0, 0, 0); // Set start date to hour/minute/second zero
      endDate.setHours(23, 59, 59, 999); // Set end date to maximum hour/minute/second
      startDateString = endDateString = formatDate(today);
      dateLabel = `${startDateString}`;
    } else if (summaryType === "Weekly") {
      startDate = getWeekStartDate(today);
      startDate.setHours(0, 0, 0, 0); // Set start date to hour/minute/second zero
      endDate = today;
      endDate.setHours(23, 59, 59, 999); // Set end date to maximum hour/minute/second
      startDateString = formatDate(getWeekStartDate(today));
      endDateString = formatDate(today);
      dateLabel = `${startDateString} to ${endDateString}`;
    } else {
      return; // No valid selection made
    }

    // Filter tasks based on the date range
    /** @type {Task[]} */
    let completedTasks = flattenedTasks.filter((task) => {
      /** @type {boolean} */
      let isDropped = task.effectiveDropDate != null;
      /** @type {boolean} */
      let isCompleted = task.effectiveCompletionDate != null;

      return !isDropped && isCompleted && task.effectiveCompletionDate >= startDate && task.effectiveCompletionDate <= endDate;
    });

    // Count tasks with no project (Inbox tasks)
    /** @type {number} */
    let inboxTasksCount = completedTasks.filter((task) => !task.containingProject).length;

    // Count tasks with a project
    /** @type {number} */
    let projectTasksCount = completedTasks.length - inboxTasksCount;

    // Determine progressed projects and mark completed ones
    /** @type {string[]} */
    let progressedProjects = [];
    /** @type {string[]} */
    let completedProjects = [];
    completedTasks.forEach((task) => {
      /** @type {Project | null} */
      const project = task.containingProject;

      if (project === null) {
        return;
      }

      /** @type {string} */
      let projectName = fullProjectPath(project);

      if (project.completed) {
        completedProjects.push(`${projectName}`);
      } else {
        progressedProjects.push(`${projectName}`);
      }
    });

    /** @type {Set<string>} */
    progressedProjects = new Set(progressedProjects.sort());
    /** @type {Set<string>} */
    completedProjects = new Set(completedProjects.sort());

    // Tasks with due dates completed during the selected period
    /** @type {number} */
    let dueTasksCount = completedTasks.filter((task) => task.dueDate).length;

    // Tasks with due dates that weren't finished during the selected period
    /** @type {Task[]} */
    let unfinishedDueTasks = flattenedTasks.filter((task) => {
      /** @type {boolean} */
      let isDropped = task.effectiveDropDate != null;
      /** @type {boolean} */
      let isCompleted = task.effectiveCompletionDate != null;

      return !isDropped && !isCompleted && task.effectiveDueDate && task.effectiveDueDate <= endDate;
    });

    // Data to be sent
    /** @type {ProductivityReport.ReportData} */
    let data = {
      date: dateLabel,
      totalCompletedTasks: completedTasks.length,
      inboxTasks: inboxTasksCount,
      projectTasks: projectTasksCount,
      progressedProjects: [...progressedProjects],
      completedProjects: [...completedProjects],
      completedTasksWithDueDates: dueTasksCount,
      unfinishedTasksWithTodaysDueDate: unfinishedDueTasks.length,
    };

    // Creating a Fetch Request
    retrieveOrRequestWebhookUrl()
      .then((webhookUrl) => {
        /** @type {URL.FetchRequest} */
        let request = URL.FetchRequest.fromString(webhookUrl);
        request.method = "POST";
        request.bodyString = JSON.stringify(data);
        request.headers = { "Content-Type": "application/json" };

        console.log(`Sending request to ${webhookUrl} with data: ${request.bodyString}...`);

        // Submit the request
        // Because it's a webhook, we'll know pretty immediately if it doesn't work.
        request.fetch();
      })
      .catch((error) => {
        console.error("Error handling webhook URL:", error);
      });
  }

  const action = new PlugIn.Action(function (selection, sender) {
    if (sender) {
      // Create a new Form
      /** @type {Form} */
      let form = new Form();
      /** @type {Form.Field.Option} */
      let summaryTypeField = new Form.Field.Option("summaryType", "Summary Type", ["Daily", "Weekly"], null, "Daily");
      form.addField(summaryTypeField);

      /** @type {Promise<ProductivityReport.FormObject>} */
      form.show("Choose Summary Type", "Continue").then((form) => {
        /** @type {string} */
        let summaryType = form.values["summaryType"];
        generateReport(summaryType);
      });
    } else {
      generateReport("Daily");
    }
  });

  /**
   * Validates the action can be performed
   * @param {Selection} selection - The current selection
   * @param {any} sender - The sender of the action
   * @returns {boolean} - Whether the action can be performed
   */
  action.validate = function (selection, sender) {
    return true;
  };

  return action;
})();
